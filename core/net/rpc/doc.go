package rpc

/*
【RPC（Remote Procedure Call）】

[参考]: https://zhuanlan.zhihu.com/p/187560185

直译远程过程调用，也叫远程方法调用。
它表示服务器 A 中的程序希望调用另外一台服务器 B 中的程序方法，因为不在一个内存空间中，所以只能通过网络来实现。

它主要侧重后端服务之间进行相互调用，也可以是移动端的接口调用。

[实现]
RPC 采用 客户端/服务端 模式，它的三个要素是：通信协议（HTTP）、寻址（IP + PORT）、数据的序列化和反序列化（JSON）

B 需要监听指定的网络端口，监听到请求后建立连接，然后，按照约定的网络传输协议，
接受参数，用于调用约定方法，然后将结果作为响应写回去；
对 A 来说，需要知道 B 的网络地址和监听的端口，才能主动发起请求、建立连接，进行数据交换。

但是，这对于需要进行 RPC 调用的客户端来说，具有相当的操作成本，上面还只是表面，实际上，还需要考虑网络连接超时、重试等问题。
所以，我一般我们会采用一种最佳实践（代理模式）
A 和 B 达成一个约定，即，方法签名，也就是语言的 接口，将其放到特定的二方库中；
然后，A 本地将调用 B 的具体逻辑封装起来，
A 通过封装的逻辑获取一个实现了指定接口的实例，这样看起来，A 直接调用本地的接口方法，就达到了调用 B 的效果。

[RPC 和 HTTP 有什么区别？]
这样的问法本身是不严谨的，HTTP 是通信协议，RPC 是远程调用方案，它的概念应该是这样的：
基于 HTTP 实现的 Restful JSON 数据格式的 接口调用，可以被称为是一种 RPC 实现。

虽然你说 HTTP 和 RPC 可能大家知道意思，但是还是应该专业一些，HTTP Restful 和 gRPC，这才是你大多数希望表达的正确意思。

说回来，就以这里上下文背景的，也是我们熟知的 HTTP Restful 形式的 RPC 和 gRPC 之间的一些区别：
传输效率：HTTP 1.1，通常包含很多包含很多无用的内容、直接基于 TCP 协议的 RPC，可以自定义上层协议，请求报文体积会更小。
性能：序列化和反序列化上，HTTP 大多是 JSON 数据格式，性能不如 gRPC 中的 protobuf；
还有基于 TCP 的 RPC 协议肯定能做到连接复用，但是 HTTP 协议就不一定了。

[RPC 框架 是什么？]
RPC 框架是为了让 RPC 的实现更加简单、透明，它封装处理了底层的传输方式、序列化方式和通信细节。
这样调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关注底层通信细节和调用过程。

[PS 常见通信协议]
网络接口层：...
网络层：IP、ICMP、ARP...
传输层：TCP、UDP
应用层：FTP、HTTP、HTTPS、SMTP、DNS...
（Socket 不是协议，是一种连接模式）

[gRPC 详见相应的模块]
*/