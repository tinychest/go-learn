package concurrency

import (
	"fmt"
	"testing"
)

/*
【通道】
[参考]: https://gfw.go101.org/article/channel.html
Goroutine 和 Channel 是 Go 的两个招牌特性，使得使用 Go 继续并发编程变得十分便利和有趣。

Go 语言设计团队的首任负责人 Rob Pike 对并发编程的一个建议是不要让计算通过共享内存来通讯，而应该让它们通过通讯来共享内存。
通道机制就是这种哲学的一个设计结果。

[类型语法]
chan xxx：  定义既能接收也能发送的通道类型
<-chan xxx：定义只能接收的通道类型
chan<- xxx：定义只能发送的通道类型
chan 可以转成 <-chan、chan<- 类型，但是反之不行

len(chan)：    通道中的元素个数；一个没有缓存区的通道 cap=0 → len=0
cap(chan)：    通道的缓冲区大小
close(chan<-)：close 方法不能关闭一个只读通道
	因为 chan 类型 可以被 <-chan 或 chan<- 类型接收，关闭通道详见下面的关闭原则

- 不能关闭已经关闭的通道
- 无法判断一个只写通道是否关闭，判断可读通道是否关闭也不是任意场合下都通用的
- 不能向一个已经关闭的通道发送消息

- 不能关闭只读的通道；一定是关闭一个可写的通道（cannot close receive-only channel）
- 不能关闭一个 nil 通道
- 从一个已经关闭的通道读取内容，能恒读取到该通道对应类型的零值
- 可以向一个已经关闭的带有缓冲区的通道正常读取缓冲区里的数据
- 向 nil 通道发送或者接收数据，都会被永久阻塞
- for-range channel 语法，会在 channel 关闭的时候且缓存区内容被读取完时（如果有缓存区）中止（结束阻塞）

【实战】

[点]
在一个值被从一个协程传递到另一个协程的过程中，此值将被复制至少一次。 如果此传递值曾经在某个通道的缓冲队列中停留过，则它在此传递过程中将被复制两次。
一般说来，为了在数据传递过程中避免过大的复制成本，我们不应该使用尺寸很大的通道元素类型。 如果欲传送的值的尺寸较大，应该改用指针类型做为通道的元素类型。

有时，一个请求可能并不保证返回一份有效的数据。对于这种情形，我们可以使用一个形如 struct{v T; err error} 的结构体类型或者一个空接口类型做为通道的元素类型以用来区分回应的值是否有效。

[select 尝试，也叫防阻塞；通道是否可用了（有消息可以获取 | 可以发送消息）]
select {
	case <-c:
		// 达成条件的操作
	default:
}

标准编译器对尝试发送和尝试接收代码块做了特别优化，使得它们的执行效率比多 case 分支的普通 select 代码块执行效率高得多。

[通知]
在一些通知场景中，我们并不关心回应的值，只关心是否发生；这时，我们常常使用 struct{} 来作为通道的元素类型，因为它的尺寸为 0，能够给节约一些内存（不多）。

- 一对一通知：一个无缓存通道；通知方完成后向通道塞值，被通知方监听通道
- 一对多通知：一个无缓存通道；通道方完成后关闭通道，被通知方监听通道（一对一也可以使用这种方式，该方式是实践中使用的最多的）
- 多对一通知：一般多使用 sync.WaitGroup

定时通知：time.Sleep And send to channel? no, use the time.After

【关闭通道】
[点]
- 重复关闭可能导致的 panic 问题 → 添加 recover 进行处理的暴力关闭
- 对通道的关闭进行相关的封装，上锁，标识位判断

[通道关闭原则]
[出处]: https://gfw.go101.org/article/channel-closing.html

一个常用的使用 Go 通道的原则是不要在数据接收方或者在有多个发送者的情况下关闭通道。换句话说，我们只应该让一个通道唯一的发送者关闭此通道
遵从上面的原则，在多个发送者定义的通用逻辑中：

为了简化下面的描述，也使文案更清晰，将一些特定场景:
“标准接收”：for range 数据通道，数据通道关了，逻辑就结束了
“标准发送”：发现达到一定的条件，该中止发送了，边关闭数据通道，跑路
“尝试跑路”：看一下关闭信号是否亮起，亮起就跑路，没有亮起什么也不做
“想跑逻辑”：循环中 [“尝试跑路”] → [数据通道是否是就绪状态，做接收或者发送操作 & 同时看着关闭信号是否亮起，亮起就跑]
“调停者逻辑”：(监听调停信号 → 等待关闭信号，跑路) & (监听关闭信号跑路)
	如果执行了后面的分支，说明实际的关闭者已经走完了逻辑，提前亮起了关闭信号；又或者者是重复调用，因为该逻辑是重复调用安全的

s：sender（发送者）
r：receiver（接收者）
n：notifier（调停者）

一、1 sender - n receiver（close(chan) - for range chan）
  s “标准发送”
  r “标准接收”

二、n sender - 1 receiver（所有引用通道的 Goroutine 都结束了，这个通道会被作为垃圾回收掉，需要额外创建一个通道，这样才不会违反原则）
  r 接收结果 → 发现已经接收到足够的结果了 → 点亮关闭信号（关闭辅助通道） → 退出
  s “想跑逻辑”

三、m sender - n receiver（思想同上，但是说将关闭额外通道的逻辑无论是放到 sender 还是 receiver 都会违反原则，所以就再起一个 Goroutine 作为中间者，负责关闭额外通道）
  s 发现发完了，“尝试” 发一个调停信号给调停者，退出；平时就是 “想跑逻辑”
  r “想跑逻辑”（接收到数据，发现收完了，也会进行 “尝试” 发一个调停信号给调停者）
  n 等待有人发起调停信号 → 点亮关闭信号 → 退出

  - 调停信道得有缓存，因为调停者可能没有准备好，那么会导致信号丢失
  - 上面的 “尝试” 可以改成直接发送，但需要将调停信道的缓存区大小设为生产者 + 消费者的数量之和

四、1 sender - n receiver（变种：基于 “一” 的变种，sender 不能主动关闭数据通道，而是由额外的 Goroutine 发起请求让 sender 关闭）
  s “想跑逻辑”（关闭信号是 notifier 发起的；无论是收到关闭信号，还是自身逻辑走完，都会关掉数据信道，发送关闭完成信号给 notifier）
  r “标准接收”
  n “调停者逻辑”（等待关闭信号被 sender 接收）

五、n sender（变种：要求数据通道一定要关闭；核心思想是，通过一个中间数据通道，将多个发送者转成一个发送者）
  定义公共的退出方法：“调停者逻辑”（中间层发起调停信号）

  s 满足一定条件，调用公用关闭方法，退出；平时就是 “想跑逻辑”（数据通道是中间数据通道）
  r “标准接收”
  n：满足一定条件，调用公用关闭方法，退出

  m（中间者 “-” 表示 select 中的多个 case，即并列）：
	- 1.接收到公用关闭方法发起的调停信号，亮起关闭信号（sender 结束），关闭数据通道（receiver 结束），退出
	- 2.中间数据通道接收到数据 →
		- 同1
		- 中间数据通道接收到的数据发向数据通道
*/

func TestChannel(t *testing.T) {
	var intChannel = make(chan int)
	close(intChannel)

	// ok 表示源值
	value, ok := <-intChannel
	fmt.Printf("value：%d，ok：%t\n", value, ok)

	t.Log(<-intChannel)
}
