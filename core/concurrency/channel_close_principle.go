package concurrency

// [通道关闭原则]
// [出处]: https://gfw.go101.org/article/channel-closing.html
//
// 一个常用的使用 Go 通道的原则是不要在数据接收方或者在有多个发送者的情况下关闭通道。换句话说，我们只应该让一个通道唯一的发送者关闭此通道
// 遵从上面的原则，在多个发送者定义的通用逻辑中：
//
// 为了简化下面的描述，也使文案更清晰，将一些特定场景:
// “标准接收”：for range 数据通道，数据通道关了，逻辑就结束了
// “标准发送”：发现达到一定的条件，该中止发送了，边关闭数据通道，跑路
// “尝试跑路”：看一下关闭信号是否亮起，亮起就跑路，没有亮起什么也不做
// “想跑逻辑”：循环中 [“尝试跑路”] → [数据通道是否是就绪状态，做接收或者发送操作 & 同时看着关闭信号是否亮起，亮起就跑]
// “调停者逻辑”：(监听调停信号 → 等待关闭信号，跑路) & (监听关闭信号跑路)
//	如果执行了后面的分支，说明实际的关闭者已经走完了逻辑，提前亮起了关闭信号；又或者者是重复调用，因为该逻辑是重复调用安全的
//
// s：sender（发送者）
// r：receiver（接收者）
// n：notifier（调停者）
//
// 一、1 sender - n receiver（close(chan) - for range chan）
//  s “标准发送”
//  r “标准接收”
//
// 二、n sender - 1 receiver（所有引用通道的 Goroutine 都结束了，这个通道会被作为垃圾回收掉，需要额外创建一个通道，这样才不会违反原则）
//  r 接收结果 → 发现已经接收到足够的结果了 → 点亮关闭信号（关闭辅助通道） → 退出
//  s “想跑逻辑”
//
// 三、m sender - n receiver（思想同上，但是说将关闭额外通道的逻辑无论是放到 sender 还是 receiver 都会违反原则，所以就再起一个 Goroutine 作为中间者，负责关闭额外通道）
//  s 发现发完了，“尝试” 发一个调停信号给调停者，退出；平时就是 “想跑逻辑”
//  r “想跑逻辑”（接收到数据，发现收完了，也会进行 “尝试” 发一个调停信号给调停者）
//  n 等待有人发起调停信号 → 点亮关闭信号 → 退出
//
//  - 调停信道得有缓存，因为调停者可能没有准备好，那么会导致信号丢失
//  - 上面的 “尝试” 可以改成直接发送，但需要将调停信道的缓存区大小设为生产者 + 消费者的数量之和
//
// 四、1 sender - n receiver（变种：基于 “一” 的变种，sender 不能主动关闭数据通道，而是由额外的 Goroutine 发起请求让 sender 关闭）
//  s “想跑逻辑”（关闭信号是 notifier 发起的；无论是收到关闭信号，还是自身逻辑走完，都会关掉数据信道，发送关闭完成信号给 notifier）
//  r “标准接收”
//  n “调停者逻辑”（等待关闭信号被 sender 接收）
//
// 五、n sender（变种：要求数据通道一定要关闭；核心思想是，通过一个中间数据通道，将多个发送者转成一个发送者）
//  定义公共的退出方法：“调停者逻辑”（中间层发起调停信号）
//
//  s 满足一定条件，调用公用关闭方法，退出；平时就是 “想跑逻辑”（数据通道是中间数据通道）
//  r “标准接收”
//  n：满足一定条件，调用公用关闭方法，退出
//
//  m（中间者 “-” 表示 select 中的多个 case，即并列）：
//	- 1.接收到公用关闭方法发起的调停信号，亮起关闭信号（sender 结束），关闭数据通道（receiver 结束），退出
//	- 2.中间数据通道接收到数据 →
//		- 同1
//		- 中间数据通道接收到的数据发向数据通道
