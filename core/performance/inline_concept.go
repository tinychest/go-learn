package performance

// 【内联】
// 来源：https://zhuanlan.zhihu.com/p/343562661
//
// 为了保证程序的执行高效与安全，现代编译器并不会将程序员的代码直接翻译成相应地机器码，它需要做一系列地检查与优化（和 MySQL 很像，MySQL 也有自己索引决策策略）
// Go 编译器默认做了很多相关工作，如，未使用的引用包检查、未使用的声明变量检查、逃逸分析、内联优化等
//
// 在 Go 中一个 Goroutine 会有一个单独地栈，栈又会包含多个栈帧（函数调用时在栈上为函数分配的空间）
// 函数调用时存在一些开销的，如维护栈帧指针寄存器 BP、栈溢出检测等，因此，对于一些代码量较少的函数，编译器
// 更倾向于将他们在编译器展开从而消除函数调用，这种行为就是内联
//
// - [禁止内联]
// Go 编译器默认将进行内联优化。
// 代码层面：只需要在不需要内联的函数的定义上加上注释：//go:noinline（不能有空格）
// 全局：可通过 -gcflags="-l" 全局禁用内联（与一个 -l 禁用内联相反，如果传递两个或两个以上的 -l 则会启用更激进的内联策略）
//
// - [实例]
// 内联对性能的提升，详见 inline_bench_test.go
//
// - [代价]
// 不相关，但是很容易就能想到，这不是和 软件工程、编码实践 中提高代码可读性的 方法复用 背道而驰么
// 内联的原理很简单，就是将函数定义的方法体替换到所有函数的调用，多次展开导致代码量的提升，进而编译后的二进制文件变大
//
// - [决策]
// > 还可参见：src/cmd/compile/internal/gc/inl.go
// 编译器是如何权衡，是否要进行内联，其实方法很简单的，就是通过 go build 的参数 `-gcflags '-m -m'`
// 添加了参数，编译时会将详细决策信息打印出来，像 MySQL 索引决策一样，会有一个代价评估
//
// 再具体一些，a = a + 1 在 AST 抽象语法树中包含 5 个节点，*o 函数中超过 80 个节点的代码量就不再内联
//
// [其他]
// closure、select、for、defer、go 都不会进行内联
//
// 内联会将函数调用过程去除，那代码的堆栈信息是否意味着会发生改变？
// 随便通过 panic 的堆栈打印，发现依然输出了正确的程序堆栈信息，包括源文件位置和行号信息
// 这是由于 Go 内部会为每个存在内联优化的 goroutine 维持一个内联树（inlining tree），该树可通过 go build -gcflags="-d pctab=pctoinline" main.go 查看
