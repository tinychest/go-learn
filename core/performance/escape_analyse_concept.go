package performance

// 先从 堆内存(heap) 和 栈内存(stack) 的概念说起
// Go 程序会在两个地方分配内存：全局的堆、每个 goroutine 独有的栈
// Go 实现了 GC(Garbage Collector) 机制，因此 Go 语言的内存管理是自动的，通常开发者并不需要关注内存是分配在哪的
//
// 但是，从性能角度，在栈上分配内存或者在堆上分配内存，性能差异是很大的；说的具体一些
// 在函数中申请一个对象，分配在栈中的内存，函数结束时，立即回收；分配在堆中，则在函数结束后的某个时间点，进行垃圾回收
// 在栈上分配和回收内存的开销很低（和 GC 无关），只需要 2 个 CPU 指令：PUSH 和 POP，一个是将数据 push 到栈空间以完成分配，pop 则是释放空间
// 也就是说在栈上分配内存，消耗的仅是将数据拷贝到内存的时间，而内存的 I/O 通常能够达到 30GB/s，因此在栈上分配内存效率是非常高的
//
// [逃逸分析]
// Go 编译器是如何决定一个变量需要分配在栈上，还是堆上呢？编译器决定内存分配位置的方式，是否分配到堆上，就称之为逃逸分析(escape analysis)
// 逃逸分析由编译器完成，作用于编译阶段
// 从专业一些的角度来说，计算机在进行函数调用时，会先进行必不可少的方法栈的空间分配，所以按理说所有在函数执行过程中声明、定义的变量都应该分配在栈上
// 但是，在某些场景下 Go 为了保证语义的正确性，而不得不返回某些变量实际的地址作为方法返回值，而如果这些内存是栈上，方法结束，内存就被回收释放了
// 无法达成目的，因此这部分内存只能从堆上申请，这就是逃逸到堆上，分析的这个过程就叫逃逸分析
//
// [命令参数]
// go build -gcflags='-m -l' xxx.go（-m 打印逃逸分析信息、-l 进制内联优化、再加一个 -m 可以看到更加详细的信息）
// 实例1：指针逃逸 - 在方法中创建了一个指针类型的实例，并作为函数返回值返回，那么这个实例一定是分配在堆上的，因为不能随着函数的结束而回收
// 实例2：interface{} 动态类型逃逸 - 例如，fmt.Println
// 实例3：栈空间内存不足 - 书上给的示例是 make([]int, 8191) < 64k、make([]int, 8192) > 64k【逃逸】、make([]int, 函数参数)【未知大小 - 逃逸】
// 实例4：闭包
//
// [利用逃逸分析来提高性能]
// 实际上，也就是方法的参数和返回值，定义为值类型还是指针类型
// 传值会拷贝整个对象，而传指针只会拷贝指针地址（指向的对象是同一个）
// 传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担
// 如非业务强制，原则上：
// 在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能
// 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能
//
// [相关参考资料]
// [官方文档]: https://go.dev/doc/faq
// How do I know whether a variable is allocated on the heap or the stack?
//
// [Go 语言高性能编程]: https://geektutu.com/post/high-performance-go.html
// [Go 101 内存块]: https://gfw.go101.org/article/memory-block.html
// [Go 101 值复制成本]: https://gfw.go101.org/article/value-copy-cost.html
