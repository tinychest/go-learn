package star

/*
Struct 和 *Struct 各有各自的类型元数据

而各自的类型元数据可以关联到各自的方法集

1. 既然，有各自的方法集，那为何限定 Struct 和 *Struct 不能有同名的方法集?
2. 为什么有 *Struct 的方法集 包含 Struct 的方法集 这种说法？

Struct 的方法集全部都是有明确定义的接收者为 Struct 类型的方法
*Struct 的方法集除了有明确定义的接收者为 *Struct 类型的方法以外，还会有编译器生成的一些包装方法
这些包装方法是对接收者为 Struct 类型的同名方法的 “包装”

为什么要编译器要为接收者为 Struct 的方法包装一个接收者为 *Struct 的同名方法呢？
通过 *Struct 类型的变量直接调用 T 类型接收者的方法，只是一种语法糖；编译器回在调用端口进行指针解引用，并不会用到包装方法

生成包装方法主要是为了接口，接口的数据结构设计到方法的自然是非空接口，它只包含两个指针，一个和类型元数据相关，一个和接口装载的数据相关
虽然有数据指针，但是不能通过指针解引用来调用值接收者的方法
因为，方法的接收者是方法调用时隐含的第一个参数，通过栈来传递的参数，如果参数类型是指针类型，那就很好实现，平台确认了，指针大小就确定了
但如果要解引用为值类型，就要有明确的类型信息，编译器才能确定这个参数，要在栈上占用多大的空间

而对于接口，编译阶段并不能确定他会装载哪一类数据，所以编译器也不能生成对应的指令来解引用

《接口不能直接使用接收者为值类型的方法》
针对这个问题，编译器选择为值接受者的方法，生成指针接收者的 “同名” 包装方法这一解决方案
结论：也就是为了接口

也正因为如此，如果我们再给 Struct 定义了和 *Struct 定义了同名方法，就有可能和编译器生成的包装方法发生冲突
所以 Go 语言不允许为 T 和 *T 定义同名方法

至于上面说的包含，可以这样理解，虽然编译器会为所有接收者为 Struct 类型的方法，生成接收者类型为 *Struct 的包装方法
但是链接器会把程序中确定不会用的方法都裁剪掉，所以去分析可执行文件的话，就会发现不只是这些包装方法，就连我们明确定义的方法，也不一定会存在可执行文件中

一定记得从可执行文件去分析，不能通过反射在程序中去验证，因为反射的实现也是基于接口，通过反射来验证，会被链接器认为用到了这个方法
从而把它保留下来，这就 “测不准” 了
*/
