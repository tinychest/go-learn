package the_func

/*
详见：https://gfw.go101.org/article/method.html

Go 中的方法，和结构体、接口紧密相关，放在 结构体 或 接口 模块都是可以的，但是，实际可以展示、表现得案例有很多
这个概念，本身蕴含的设计理念也比较深厚（懂得越多，不懂得越多）

当为一个类型声明了一个方法后，每个该类型的值将拥有一个和此方法同名的成员函数，
此类型的零值也不例外，不论此类型的零值是否用 nil 来表示。（只要类型正确，即使是 nil，语法上也可以正常调用该类型的方法，注意 nil panic）

【方法定义】
在 Go 中，可以为类型 T 和 *T 显示声明一个方法，其中类型 T 必须满足四个条件
- T 必须是一个定义类型（详见当前目录下的 type_define_concept.go）
- T 必须和此方法声明定义在同一个代码包下
- T 不能是一个指针类型
- T 不能是一个接口类型

【术语定义】
方法的方法名左边标识的所属结构体被称为方法的 属主，也叫 接收者（Receiver）
指针类型属主、非指针类型属主
一般把有属主的称为方法，没有属主的成为函数

[拓展]
在很多其它面向对象的编程语言中，属主参数名总是为隐含的，this 或 self，但是这样的名称不推荐在 Go 中使用

【Receiver 类型】
针对方法 Receiver 类型的定义（是否带星）总结来说有如下几点（官方）
- 方法能够修改其接收者指向的值
- 可以避免在每次调用方法时复制该值（值传递）。若值的类型为大型结构体时，这样做会更加高效
- 通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用

【方法集】
- Receiver 的方法总是 *Receiver 的方法的超集（*Receiver 实现的接口，Receiver 并没有实现）
[没有方法集的类型]
- 内置基本类型
- 定义的指针类型
- 基类型为 指针类型或者接口类型 的指针类型
- 非定义的 数组/切片/映射/函数/通道类型

【其他】
- 这里边经常有误区，因为为 Receiver 绑定的方法，*Receiver 类型也可以直接调用，
  经常会误认为 *Receiver 调用 Receiver 的方法，能够对实际 Receiver 的 值产生影响。
  只有在接口实现上，能够体现出该真实性
- *XxxInterface 不能直接调用 XxxInterface 的方法。
- 为类型别名声明方法的效果，等同于为类型声明方法。
- 不同代码包中的同名非导出方法将总被认为是不同名的。

【总结】
如何决定一个方法声明使用值类型属主还是指针类型属主？（Go 101）
- 有时候我们必须在某些方法声明中使用指针类型属主。
- 事实上，我们总可以在方法声明中使用指针类型属主而不会产生任何逻辑问题。
  我们仅仅是为了程序效率考虑有时候才会在函数声明中使用值类型属主。

- 太多的指针可能会增加垃圾回收器的负担。
- 如果一个值类型的尺寸太大，那么属主参数在传参的时候的复制成本将不可忽略。（详见 Go 101 值复制代价）
- sync标准库包中的类型的值不应该被复制，所以如果一个结构体类型内嵌了这些类型，则不应该为这个结构体类型声明值类型属主的方法。（参见 no_copy_test.go）

结论：如果实在拿不定主意在一个方法声明中应该使用值类型属主还是指针类型属主，那么请使用指针类型属主。
*/
