package todo

import "testing"

// [单位]
// b：bit 二进制位
// kb：常用在传输速率的表达上 = 1024 b（不要把 k 单独拿出来理解为 千，以为等于 1000）
// B（BS）：byte（bytes） 字节 = 8 b
// KB：简称 K，常用在文件大小、容量的表达上 = 1024 B
// MB：简称 M = 1024 KB
// GB：简称 G = 1024 MB（通常简称为了）
//
// 注意，在 K 和 Ki 的对比场景下， K 表示 10 进制下的 1000，Ki 表示 2 进制的 1024
// 多出的 i 并不是什么单词的缩写，千 的词根就是 kilo，上面的就是一种约定，记住就好

// 【码】
// 正数、无符号数：三码合一（原码 = 反码 = 补码）
// 负数：
// - 原码 最高位符号位为 1
// - 反码 规定由原码进行符号位不变的取反操作得到
// - 补码 规定由补码加 1 得到
//
// 在只使用 + 的 无符号数世界里，根本就不需要补码的概念
// 为什么要有补码，计算机的硬件结构就只有加法器，所以遵从 《模》 的概念，为了将所有的减法转化成加法
// （最开始其实是通过反码来解决的，但是发现十分复杂，于是便衍生出补码）
//
// 你看上去，你觉得的加减法，实际在计算机世界中只有加法，因此引出补码，这样就能计算减法了：补码的加法
// A - B → A补码 + (-B)补码 = C补码 -取反加1→ C
//
// [例0]
// 有符号的 8 位数 1
// 原码：0000 0001
// 反码：0000 0001
// 补码：0000 0001
// 取反：1111 1110
// 求补（取反加1）：1111 1111
//
// 有符号的 8 位数 -1
// 原码：[1]000 0001
// 反码：[1]111 1110
// 补码：[1]111 1111
//
// 你会发现 1 取反加 1正好就是 -1 的补码
// （有时候会表述为 1 的补码，这是错误的偷懒表述，你明白意思，记住有符号数的正数三码合一就行）
//
// [例1]
// -1 原码：1000 0001
// -1 反码：1111 1110
// -1 补码：1111 1111
// 2 - 1 → 0000 0010 + 1111 1111 = 1 0000 0001 → 溢位丢弃 → 0000 0001 这是 1 的补码，因此答案就是 1
//
// 8 位有符号数无法表示 128（那一位正好是符号位，超出限制），但为什么说 -128 的补码是 1000 0000？（有很多种说法，下面两种比较能接受）
// 一、数学方程置换角度
// 256 - 128 = 128
// → 256 + (-128的补码) = 128
// → (-128的补码) = 256 - 128 = 128 = 1000 0000
//
// 二、规定角度（既然规定了是有符号数的环境，那么最高位就是符号位）
// [0]000 0000 → 0
// [0]111 1111 → 127
// [1]111 1111 → -127
// 能表示 [-127, 127] 很直白
// [1]000 0000 → -0 = 0（已经有了），所以它就是 128
func TestComputerBasic(t *testing.T) {
	// var s int8 = 0b1000_0000 // NO，Go 的数字都是整型，所以这里不行
	// t.Logf("%b", int8(-1)) // NO，打印的是 -1

	// int8 数据类型范围 [-128, 127]

	var a int8 = -1
	var b int8 = -128 / a
	t.Log(b)

	// 127  0111 1111（道理）
	// -128 / -1 的结果很简单就是 128（理所当然），在内存的结果就是 0(符号位) 1000 0000，但是现在要转 int8 存不下额外的符号位信息

	// 说的再清楚一些，计算机中的计算、存储都是补码
	// 就是计算结果：0(符号位)000 0000 0000 0000 0000 0000 1000 0000，但是实际只有 8 位的存储空间
	// 那么就只能舍弃其他的位了，重要的就是符号位被丢弃了，所以 b变量存储的补码值就是 1000 0000，对应的十进制数就是 -128

	t.Log(-128 / -1)
	// t.Log(-128 / int8(-1)) // 编译不通过
}
