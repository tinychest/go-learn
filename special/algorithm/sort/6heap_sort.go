package sort

// 【堆排序】
//
// 可以很轻松从算法动画中了解到，算法核心思想
// 其实就是二叉树，但是并不是真实构建出二叉树的数据结构；
// 假如现在有一个颗二叉树，我们按照 从左向右 从上到下 的顺序，遍历这棵树的所有节点，得到一个数组
// 这时可以发现一个规律，节点的两个子节点的下标等于 当前节点的下标*2 + 1 和 当前节点的下标*2 + 2。
// 以及，含有子节点的（二叉树特性，二叉树上的叶子节点数量 = 二叉树所有非叶子节点的数量 + 1）节点下标范围 [0, len/2)
//
//
// 构建 大顶堆 或者 小顶堆
// 什么是堆，堆是类似完全二叉树的数据结构，并且满足树上每一个节点的值都比两个子节点的值小或者大
// 什么是完全二叉树，对于一个树高为 h 的二叉树，如果其第0层至第 h-1 层的节点都满。如果最下面一层节点不满，则所有的节点在左边的连续排列，空位都在右边。这样的二叉树就是一棵完全二叉树（还有 满二叉树 的概念）
// 什么是二叉树，树的每个节点最多有两个子节点
// 什么是树，算了，你回家吧
//
// 以构建 大顶堆 为例
// 假定二维数组下标为 0 的位置，正好是二叉树的根，那么只需要从下标为 len/2-1 开始的节点向前边，将每个节点与其两个子节点进行比较，将大的字节晋升为父节点
// 这样一轮下来，我们就构建了一个大顶堆，并且根上，也就是下标为 0 的数，就是最大的数
//
// 这时我们将根和二维数组末端的数进行交换；然后，缩小数组范围，相当于将最后一个节点从树上摘去；
//
// 再次进行上面的构建流程...最终，只剩一个节点，此时数组就已经是一个从小到大排好序了的数组了
//
// [是否稳定] false
//
// [空间复杂度] O(1)
//
// [时间复杂度]
// - 平均 O(nlogn)
// - 最优 O(nlogn)
// - 最劣 O(nlogn)

func HeapSort(arr []int) {
	for i := 0; i < len(arr); i++ {
		buildMaxBucket(arr[:len(arr)-i])

		arr[len(arr)-1-i], arr[0] = arr[0], arr[len(arr)-1-i]
	}
}

func buildMaxBucket(arr []int) {
	for i := len(arr)/2 - 1; i >= 0; i-- {
		if arr[i] < arr[i*2+1] {
			arr[i], arr[i*2+1] = arr[i*2+1], arr[i]
		}
		// 注意，不一定有右子节点
		if len(arr) > i*2+2 && arr[i] < arr[i*2+2] {
			arr[i], arr[i*2+2] = arr[i*2+2], arr[i]
		}
	}
}
