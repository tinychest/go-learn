package leetcode

// 刷 leetcode 可以提升算法能力，这是被广为人知，业界普遍认可的方式；很多大厂的算法笔试题都是源于 leetcode，或者就是 leetcode 原题。
//
// [做题要点]
// - 对于初学者来说，一道题的用时，需要好好掂量，不要一直跌死在一个坑里；早期不熟，当超过 半个小时 或者 1 个小时 都还没有任何思路，
//   就应该去查找相关资料 或 查看参考答案（如果有的话）。
// - 一般完成一道 leetcode 题，会推荐相关的体型，建议去接着完成相关的题型；因为 leetcode 刷题是有讲究的，就是一种类型的题一直刷，
//   这样才能熟能生巧，就能领悟某一类题目的关联和解题技巧和思路；否则，没有关联，做过的题型特别容易忘记。
// - leetcode 上的题有着简易的评价系统，如果 👍 和 👎 的比例接近 1 : 1，其实就没有去写的意义了，这种题要不是特别绕，要不就是实现了，也收获不了什么。
//
// [Something you should know]
// - 因为计算机基础知识，你无法获取精准的执行时间，所以，会导致一个现象，你多次提交代码得到的代码执行时间是不一样的（当然，你算法效率确实低，就别妄想了）
// - 但是，相同的代码执行多次，每次的内存分配肯定是一样的
// - leetcode 统计内存使用应该是把所有测试用例使用的内存加起来的，不是说什么平均、中位数，有时候你就申请了个位数的 int 变量也能得到 MB 级别的内存使用结果
//
// 因为 leetcode 大多数题的 Solution 板块是要收费的，假如遇到不会做的题：
// - 可以在 Submissions 板块中，点击你的提交状态（意味着，你尝试提交过，且通过了全部的测试用例，超不超时倒无所谓）
//   可以看到所有提交的统计条形分布图，任意一个柱条都是可以点的，可以查看到题目的解法
// - 如果光看代码实在不理解，可以去友善的 Discuss 板块中找一些阅读量比较高的帖中进行了解
// - 可以去 B 站搜一下，有些 UP 主把自己的做题流程记录下来了
//
// 项目中的做题规范说明
// 1. 创建对应名称的包（<序号><算法题的英文名 中划线改下划线>）
// 2. 创建 slove.go
// 3. 从 leetcode 上把待实现的方法签名复制下来
// 4. 对方法签名 Ctrl + Shift + T 生成测试用例方法
// 5. 将 leetcode 上的测试样例复制下来
// 6. 编写代码（每次准备提交前都先本地跑一下样例 → leetcode 上跑测试 → 提交）
// 7. 凡是提交失败，都要将相关原因记录下来、将失败案例补充到本地的测试样例中
//      假如实现的不好（不是逻辑错误），如超时，也将其以 step<n> 为方法名的形式记录下来，并说明哪里实现的不好
//      调整思路，迭代 step<n> 方法记录；直到达到理想的提交效果，或者做题时间过久，卡住了
// 8. 参考 leetcode 中的讨论
//     在 solve.go 中以 方法名为 refer<n> 相同的方法签名记录下来
// 9. 参考 leetcode 中的答案
//     将其记录到 solve_pref.go 中
// 10. 不要将目标函数的结果集定义为全局变量，特别是当存在获取最小值逻辑的时候，这样会导致进行多组测试用例测试时，结果错误
//
// [common 说明]
// - 有一些基于特定数据结构的题如链表，在编写 table 测试用例时，会用到的辅助方法，为了避免代码重复，特地创建了一个文件夹存放
//
// [注释说明]
// 做题记录中，提到的 ”参考“ ”参考答案“ 都是指，所有提交中，耗时最短的
