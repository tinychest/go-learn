package leetcode

// [Something you should know]
// - 因为计算机基础知识，你无法获取精准的执行时间，所以，会导致一个现象，你多次提交代码得到的代码执行时间是不一样的（当然，你算法效率确实低，就别妄想了）
// - 但是，相同的代码执行多次，每次的内存分配肯定是一样的
// - leetcode 统计内存使用应该是把所有测试用例使用的内存加起来的，不是说什么平均、中位数，有时候你就申请了个位数的 int 变量也能得到 MB 级别的内存使用结果
//
// 因为 leetcode 大多数题的 Solution 板块是要收费的，假如遇到不会做的题：
// - 可以在 Submissions 板块中，点击你的提交状态（意味着，你尝试提交过，且通过了全部的测试用例，超不超时倒无所谓）
//   可以看到所有提交的统计条形分布图，任意一个柱条都是可以点的，可以查看到题目的解法
// - 如果光看代码实在不理解，可以去友善的 Discuss 板块中找一些阅读量比较高的帖中进行了解
// - 可以去 B 站搜一下，有些 UP 主把自己的做题流程记录下来了
//
// 项目中的做题规范说明
// 1. 创建对应名称的包（<序号><算法题的英文名 中划线改下划线>）
// 2. 创建 slove.go
// 3. 从 leetcode 上把待实现的方法签名复制下来
// 4. 对方法签名 Ctrl + Shift + T 生成测试用例方法
// 5. 将 leetcode 上的测试样例复制下来
// 6. 编写代码（每次准备提交前都先本地跑一下样例 → leetcode 上跑测试 → 提交）
// 7. 凡是提交失败，都要将相关原因记录下来、将失败案例补充到本地的测试样例中
//      假如实现的不好（不是逻辑错误），如超时，也将其以 step<n> 为方法名的形式记录下来，并说明哪里实现的不好
//      调整思路，迭代 step<n> 方法记录；直到达到理想的提交效果，或者做题时间过久，卡住了
// 8. 参考 leetcode 中的讨论
//     在 solve.go 中以 方法名为 refer<n> 相同的方法签名记录下来
// 9. 参考 leetcode 中的答案
//     将其记录到 solve_pref.go 中

// [common 说明]
// - 有一些基于特定数据结构的题如链表，在编写 table 测试用例时，会用到的辅助方法，为了避免代码重复，特地创建了一个文件夹存放
