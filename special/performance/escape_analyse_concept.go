package performance

// 先从 堆内存(heap) 和 栈内存(stack) 的概念说起
// Go 程序会在两个地方为变脸分配内存：全局的堆、每个 goroutine 的栈
// Go 实现了 Garbage Collector 机制，因此 Go 语言的内存管理是自动的，通常开发者并不需要关注内存是分配在哪的

// 但是，从性能角度，在栈上分配内存或者在堆上分配内存，性能差异是很大的；说的具体一些
// 在函数中申请一个对象，分配在栈中的内存，函数结束时，自动回收； 分配在堆中，则在函数结束后的某个时间点，进行垃圾回收

/* 在栈上分配和回收内存的开销很低 */
// 只需要 2 个 CPU 指令：PUSH 和 POP，一个是将数据 push 到栈空间以完成分配，pop 则是释放空间，
// 也就是说在栈上分配内存，消耗的仅是将数据拷贝到内存的时间，而内存的 I/O 通常能够达到 30GB/s，因此在栈上分配内存效率是非常高的

/* 什么是逃逸分析 */
// Go 编译器怎么知道某个变量需要分配在栈上，还是堆上呢？编译器决定内存分配位置的方式，就称之为逃逸分析(escape analysis)
// 逃逸分析由编译器完成，作用于编译阶段
// 用自己的话说就是：本该分配在栈上的内存，逃逸，分配到堆上了

// 命令：go build -gcflags=-m xxx.go

// 实例1：指针逃逸 - 在方法中创建了一个指针类型的实例，并作为函数返回值返回，那么这个实例一定是分配在堆上的，因为不能随着函数的结束而回收
// 实例2：interface{} 动态类型逃逸 - 例如，fmt.Println
// 实例3：栈空间内存不足 - 书上给的示例是 make([]int, 8191) < 64k、make([]int, 8192) > 64k【逃逸】、make([]int, 函数参数)【未知大小 - 逃逸】
// 实例4：闭包
// 闭包：一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围）
// 这样的组合就是闭包（closure）。也就是说，闭包让你可以在一个内层函数中访问到其外层函数的作用域
// 被闭包函数引用的变量，不能因为所在函数结束而被回收，所在会分配在堆上

// 利用逃逸分析来提高性能：也就是方法传值还是传指针
// 传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个
// 传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担
// 在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能

// 一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存较小的结构体，直接传值能够获得更好的性能
